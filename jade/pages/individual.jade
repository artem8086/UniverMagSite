h1 Базовые принципы работы интерпретаторов
p #[b Интерпретатор]#[sup #[a(href='#ind-link1')= '[1]']] &ndash; программа выполняющая построчный анализ, обработку и выполнение исходного кода программы или запроса (в отличие от компиляции, где весь текст программы, перед запуском, анализируется и транслируется в машинный или байт-код, без её выполнения).
P Интерпретируемые или скрипотовые языки программирования на сегодняшний день широко используются как языки сценариев для администрирования операционной системы, как встраиваемые языки или для создания прикладного программного обеспечения. Основными преимуществами скриптовых языков является:
ul
	li переносимость программного кода между платформами, на которых реализован интерпретатор;
	li существенно более быстрая загрузка скрипта и начала его выполнения по сравнению с транслируемыми языками, что позволяет на стадии разработки более регулярно вносить изменения и тестировать их;
	li более совершенные средства отладки и диагностики ошибок в исходном коде;
	li зачастую меньший размер исходного кода по сравнению с транслируемыми в машинный код языками.
p Недостатками являются:
ul
	li невозможность запуска скрипта без интерпретатора, при этом интерпретатор может быть как довольно компактным, так и нет.
	li скрипты выполняются медленнее, поскольку выполняется анализ кода и планирование его выполнения требует дополнительного времени в сравнении с непосредственным исполнением машинного кода;
	li оптимизация кода зачастую либо отсутствует полностью, либо является недостаточно эффективной, что также сказывается на скорости выполнения программы.

p Не смотря на недостатки со скоростью выполнения программ интерпретаторами, зачастую их встраивают в приложение, чтобы иметь возможность расширять его функционал без перекомпиляции. Скрипты обычно некритичны к скорости выполнения задачи, а требовательные к производительности участки выполняются за счет вызова подпрограмм на машинном коде из скрипта. Самым ярким представителем встраиваемых скриптовых языков, является JavaScript в браузерах, который позволяет выполнять интерактивные действия на веб страницах, и работает на всех системах в которых есть интернет браузеры.

h2 Основные этапы работы интерпретатора
p Каждый интерпретатор после получения исходного кода скрипта (будь то загрузка из файла, или получение в параметре в виде строки), выполняет следующие действия:
ol
	li 
		a(href='#ind_tokens') Лексический анализ
	li
		a(href='#ind_syntax') Синтаксический анализ
	li
		a(href='#ind_optimization') Оптимизация (опционально)
	li
		a(href='#ind_runtime') Выполнение

h2#ind_tokens Лексический анализ
p Лексический анализ или токенизация (от англ. token &ndash; знак; представление лексемы в виде обьекта) &ndash; процесс разбиения исходного текста программы на лексемы (токены), которые являются атомарными сущностями языка, такие как. числа, строки, операторы и разделительные знаки. С такими сущностями интерпретатору далее будет намного удобней работать. На этом этапе также опускаются комментарии и сокращаются последовательности пробельных символов. Процесс примерного разбиение на лексемы показан на #[a(href='#ind_img1') рисунке 1].

+image('tokens.jpg', 'Пример разбиение исходного текста программы на лексемы')#ind_img1

p При лексическом анализе в строках также заменяются управляющие последовательности символов. Для того чтобы в случае возникновении ошибки, была возможность сообщить о её местоположении в исходном коде, в токенах также сохраняется информация с номером строки и первого символа лексемы. Таким образам после лексического анализа мы получем список токенов.

h2#ind_syntax Cинтаксический анализ
p Получив список токенов интерпретатор выполняет синтаксический анализ, проверяя расположения лексем в управляющих конструкциях и выражениях в соответствии с правилами языка программирования. Параллельно с проверкой на корректность кода, синтаксический анализатор строит в памяти абстрактное синтаксическое дерево (AST &ndash; англ. Abstract Syntax Tree)#[sup #[a(href='#ind-link2')= '[2]']], в котором узлами являются операторы, а листья представляют собой либо переменные, либо константы.

+image('ast.jpg', 'Пример абстракного синтаксического дерева')#ind_img2

p После постройки абстрактного синтаксического дерева список токенов далее не будет участвовать в процессе интерпретации и можно освободить память, использующуюся для его хранения. В каждом узле дерева также стоит сохранять информацию о месторасположении синтаксической конструкции в исходном коде, которую можно получить из токенов, это позволит выводить более детальную информации об ошибках времени исполнения.

h2#ind_optimization Оптимизация

p Оптимизация в интерпретаторах может производится по усмотрению разработчика, так как обычно оптимизация осуществляется только по одному критерию, а именно либо по скорости выполнения, либо по потреблению памяти. И так, после формирования абстрактного синтаксического дерева интерпретатор может произвести несколько базовых оптимизаций, характерных как для интерпретаторов, так и для компиляторов.

p Свёртка констант (англ. Constant Folding)#[sup #[a(href='#ind-link3')= '[3]']] &ndash; эта оптимизация рекурсивно проходит по всем узлам абстрактного синтаксического дерева и если все листья являются константами, то узел вычисляется и заменяется вычисленной константой. Иначе говоря, эта оптимизация заменяет выражения, которые можно посчитать на этапе трансляции. Например, x = (10 + 5) * y; можно заменить на х = 15 * y.

p Распространение констант (англ. Constant Propagation)#[sup #[a(href='#ind-link4')= '[4]']] &ndash; подстановка значений вместо констант. Например:
code.
	const x = 5;<br>
	var y = 2 * x - 8;<br>
p Поскольку x имеет константное значение 5, мы можем подставить его во второе выражение:
code.
	const x = 5;<br>
	var y = 2 * 5 - 8;<br>
p Далее свёртка констант посчитает выражение и мы получим:
code.
	const x = 5;<br>
	var y = 2;<br>

p Удаление мёртвого кода (англ. Dead Code Elimination, DCE)#[sup #[a(href='#ind-link5')= '[5]']] &ndash; оптимизация удаляет пустые блоки кода и узлы выполняющие бесполезные вычисления.

p Упрощение выражений (англ. Expression Simplification) &ndash; эта оптимизация заменяет выражения на аналогичные, но более эффективные. Например: x = y * -1 можно заменить на x = -y.

p #[b JIT-компиляция] (англ. Just-in-time compilation, компиляция «на лету»), #[b динамическая компиляция] (англ. dynamic translation)#[sup #[a(href='#ind-link6')= '[6]']] &ndash; промежуточная компиляция абстрактного синтаксического дерева в байт-код некоторой виртуальной машины или машинный код конкретной платформы. За счёт этого может достигаться скорость выполнения программы сравнимая с компилируемыми программами. Однако возрастают требования к потреблению памяти и повышаются начальные временные затраты так как появляется дополнительная стадия компиляции.

h2#ind_runtime Выполнение
p Этап выполнения зависит была ли использована JIT-компиляция или нет. При отсутствии JIT-компиляции интерпретатор начинает рекурсивно проходит по каждому узлу абстрактного синтаксического дерева и выполняет операцию, ассоциированную с данным узлом. В случае использования JIT, в зависимости от вида компиляции, либо выполняется байт-код на виртуальной машине (что требует ещё и включения виртуальной машины в состав интерпретатора), либо исполняется непосредственно машинный код.

h2 Выводы
p Скриптовые языки играют важную роль в современной IT сфере и понимание принципов работы интерпретаторов позволит создавать более качественные скриптовые программы. Также стоит отметить собственные разработки автора#[sup #[a(href='#ind-link7')= '[7]']] в данной сфере, а именно небольшой встраиваемый язык для приложений на платформе Java, синтаксически напоминающий JavaScript.


h2 Ссылки
ol.links
	li#ind-link1
		a(href='https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80') Интерпретатор

	li#ind-link2
		a(href='https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE') Абстрактное синтаксическое дерево

	li#ind-link3
		a(href='https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82') Свёртка констант

	li#ind-link4
		a(href='https://ru.wikipedia.org/wiki/%D0%A1%D0%B2%D1%91%D1%80%D1%82%D0%BA%D0%B0_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82#%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%BE%D1%81%D1%82%D1%80%D0%B0%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D0%B0%D0%BD%D1%82') Распространение констант

	li#ind-link5
		a(href='https://ru.wikipedia.org/wiki/%D0%A3%D0%B4%D0%B0%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5_%D0%BC%D1%91%D1%80%D1%82%D0%B2%D0%BE%D0%B3%D0%BE_%D0%BA%D0%BE%D0%B4%D0%B0') Удаление мёртвого кода

	li#ind-link6
		a(href='https://ru.wikipedia.org/wiki/JIT-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%86%D0%B8%D1%8F') JIT-компиляция

	li#ind-link7
		a(href='https://github.com/artem8086/ArtSoftScriptEngine') Встраиваемы язык ArtSoft Script (собственная разработка)