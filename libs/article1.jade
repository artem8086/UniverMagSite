include ../jade/blocks/base-lib

- var name = 'Разработка демонстрационной модели гипотетического компьютера';
- var authors = 'Святоха А.А.';

+lib(name, authors)
	h1= name
	
	p.no-indent #[strong Авторы:] #{authors}

	ul.content-list
		li
			a(href='#intro') Введение
		li
			a(href='#p1') 1. Анализ средств и способов моделирования компьютерных систем
			ul
				li
					a(href='#p1_1') 1.1 Виды моделей
				li
					a(href='#p1_2') 1.2 Анализ средств
				li
					a(href='#p1_3') 1.3 Примеры моделей компьютерных систем
			a(href='#p2') 2. Разработка демонстрационной модели гипотетического компьютера
			ul
				li
					a(href='#p2_1') 2.1 Анализ объектов моделирования
				li
					a(href='#p2_2') 2.2 Обоснование выбора платформы
				li
					a(href='#p2_3') 2.3 Разработка программной модели
		li
			a(href='#conclusion') Выводы
		li
			a(href='#literature') Литература

	h1#intro Введение
	p С каждым годом возрастает роль средств вычислительной техники, при этом все компоненты вычислительных систем располагаются на интегральных микросхемах, не позволяя получить доступ к отдельным узлам или элементам, осложняя тем самым процесс изучения функционирования компьютерных систем и их компонентов.
	p Глубокое понимание принципов построения и функционирования сложных систем достигается лишь при практической работе с такими системами или их моделями. Даже самое подробное описание работы с базовым цифровым устройством и детальные иллюстрации процесса выполнения команд не могут заменить действительной работы с этим устройством.
	p Данная проблема особенно актуальна в технических вузах и для ее решения разрабатываются специальные модели: физические или функциональные#[sup #[a(href='#link1')= '[1]']], наглядно демонстрирующие представление данных, выполнение операций, взаимодействие с периферией по средствам операций ввода-вывода и системы прерываний.

	h1#p1 1. Анализ средств и способов моделирования компьютерных систем
	h2#p1_1 1.1 Виды моделей
	p Для моделирования компьютерных систем разрабатываются специальные модели: физические и функциональные#[sup #[a(href='#link1')= '[1]']].
	p Физическая модель – это стенд со структурой изучаемого устройства микропроцессорной техники, построенный на интегральных схемах малой и средней степени интеграции и снабженный средствами для управления режимами работы исследуемого устройства, а также индикации состояний любых его компонентов.  В связи с быстрой эволюцией средств микропроцессорной техники массовый выпуск таких специализированных стендов нецелесообразен.  Экономически невыгодно и их мелкосерийное производство.
	p Физические модели позволяют проводить физическое исследование компьютеров и цифровых устройств, но так как ввиду роста развития вычислительной техники материальная база быстро устаревает и требует периодической замены лабораторной базы. Кроме того, такие комплексы хороши для подготовки высококвалифицированных кадров в области компьютерной инженерии, но сложны и избыточны для обучения студентов других специальностей.
	p Функциональная модель – это компьютер, в который введена программа, имитирующая работу исследуемого устройства микропроцессорной техники под воздействием приказов, подаваемых со специально разработанного пульта управления или, например, со стандартной клавиатуры и мыши компьютера. Состояния компонентов исследуемого устройства отображаются на индикаторах специального пульта или на мониторе компьютера.
	p Функциональные модели не требуют специального оборудования, и могут быть продемонстрированы на обычном компьютере, вся необходимая информация отображается на мониторе, и имеется возможность интерактивного взаимодействия с пользователем системы. У функциональной модель также легко изменять как структуру, так и программу изучения функционирования компьютеров либо любого цифрового устройства.

	h2#p1_2 1.2 Анализ средств
	p Функциональные   модели   чрезвычайно универсальны: одни и те же технические средства позволяют производить изучение процесса преобразования информации в любых цифровых устройствах и с любой степенью детализации. Для исследования нового устройства надо только сменить моделирующую программу, программу вывода на экран изображения структуры моделируемого устройства и программу отображения состояния компонентов этого устройства.
	p В соответствии со своим назначением функциональная модель должна правильно и полно отражать состояния лишь индицируемых компонентов оригинала и только в индицируемые моменты времени.
	p Поэтому   функциональное   моделирование   простейших   цифровых устройств можно выполнять с помощью программы, которая по сигналам органов управления выбирает из памяти и отображает на мониторе соответствующие им состояния компонентов оригинала.
	p Следовательно, при создании функциональной модели надо в первую очередь заботиться о способах ввода управляющих сигналов и вывода информации о состояниях моделируемого устройства, т. е. о факторах, определяющих необходимые уровень и полноту исследования. Та же часть программного обеспечения модели, с помощью которой анализируются текущее ее состояние, наличие сигналов, инициирующих переход в следующее состояние, и определяется новое содержимое индицируемых компонентов оригинала, быть построена любым удобным для разработчика способом.
	p Если функциональная модель цифрового устройства реализуется с помощью персонального компьютера, то взаимодействие с такой моделью проще и дешевле всего организовать через клавиатуру и мышь этого компьютера и его монитор.
	p Первым представителем функциональных моделей является PROTEUS VSM#[sup #[a(href='#link3')= '[3]']], который входит в пакет программ Proteus Design Suite - САПР разработанная компанией Labcenter Electronics (Великобритания). Отличительной чертой пакета PROTEUS VSM является возможность моделирования работы программируемых устройств: микроконтроллеров, микропроцессоров, DSP и проч. Библиотека компонентов содержит справочные данные. Дополнительно в пакет PROTEUS VSM входит система проектирования печатных плат.

	+image('proteus.png', 'Вид главного окна системы PROTEUS VSM', '1.1')

	p TkGate#[sup #[a(href='#link4')= '[4]']] — среда моделирования и симуляции цифровых электронных схем, состоящая из графического редактора с интерфейсом, основанным на tcl/tk и управляемого событиями симулятора. TkGate поддерживает большое количество готовых примитивов, от отдельных транзисторов и вентилей, до стандартных комбинационных и последовательных элементов логических схем. Кроме этого, поддерживается определение модулей в виде графических логических схем или Verilog описаний, а также библиотек модулей для создания сложных иерархических моделей с переиспользованием кода. В дистрибутив входят примеры схем и учебное руководство.

	+image('tkgate.png', 'TkGate 2.0.0', '1.2')

	h2#p1_2 1.3 Примеры моделей компьютерных систем
	p В 1982-83 гг. доцент доцент Кириллов В.В. разработал программную модель «Базовой ЭВМ», которая была реализована на "Искра-226" студентами Громовым Г.Ю., Громовой И.В. и Дергачевым А.М#[sup #[a(href='#link1')= '[1]']].

	+image('sheme1.png', 'Обобщённая структурная схема компьютера<sup><a href="#link1">[1]</a></sup>', '1.3')

	p Был разработан и изготовлен специальный пульт управления моделью и индикации ее состояний позволит организовать наиболее эффективное взаимодействие с моделью и получить всю необходимую информацию о ее функционировании.
	p На #[a(href='#img1_4') рисунке 1.4,а] приведен внешний вид, а на #[a(href='#img1_4') рисунке 1.4,б] – структурная схема пульта управления  и  индикации,  используемого  для  изучения работы базовой ЭВМ. Пульт состоит из набора тумблеров и кнопок, индикатора матричного газоразрядного (ИМГ-3), контроллера для связи клавиатуры и индикатора с управляющей (моделирующей) ЭВМ.

	+image('sheme2.png', 'Пульт   управления   и индикации   функциональных моделей микроЭВМ: а - внешний вид; б - структурная схема<sup><a href="#link1">[1]</a></sup>', '1.4')#img1_4

	p ИМГ-3 – газоразрядная панель с устройством управления, которое может зажечь любой из 4096 (64X64) элементов изображения (ЭИ) размером 3X3 мм, расположенных на расстоянии 3 мм друг от друга. На панель накладывается маска со структурой базовой ЭВМ или ее микропрограммным устройством управления. В изображениях регистров и других устройств этих масок пробиты круглые отверстия, расположенные над ЭИ панели.  Моделирующая программа зажигает ярким зеленым цветом ряд ЭИ, соответствующих единичным состояниям тех или иных разрядов устройств базовой ЭВМ.
	p Для задания адреса ячейки памяти или ввода данных в модель базовой   ЭВМ, построенной   на "Искра 226", используются функциональные клавиши клавиатуры этой персональной ЭВМ (#[a(href='img1_5') рисунок 1.5]).

	+image('photo1.jpg', 'Профессиональная персональная ЭВМ «Искра 226»', '1.5')#img1_5

	h1#p2 2. Разработка демонстрационной модели гипотетического компьютера
	h2#p2_1 2.1 Анализ объектов моделирования
	p Гипотетическая компьютерная система предназначена в первую очередь наглядно продемонстрировать основы работы компьютера, и всех его подсистем, таких как подсистема памяти, управления и подсистем ввода-вывода. Практически любой компьютер содержит в себе процессор, в состав которого входят#[sup #[a(href='#link1')= '[1]']]:
	ul.no-mark
		li - устройство управления выборкой команд из памяти и их выполнением;
		li - арифметико-логическое устройство, производящее операции на данными;
		li - регистры, осуществляющие временное хранение данных и состояний процессора;
		li - схемы для управления и связи с подсистемами связи и вводы-вывода.
	p В понимания принципов функционирования и взаимосвязи этих систем, помогает демонстрационная модель гипотетической компьютерной системы. Которая позволяет следить за изменением состояния системы, в любом промежутке её работы.

	+image('sheme3.png', 'Структурная схема рассматриваемой модели', '2.1')

	h2#p2_2 2.2 Обоснование выбора платформы
	p Для разработки демонстрационной модели были выбраны языки разработки веб приложений HTML5, CSS3 и JavaScript. Выбор базируется на кроссплатформенности платформы веб, запуске приложения без необходимости компиляции, простоту разработки, а также богатыми средствами визуализации и интерактивного взаимодействия с пользователем. К минусам данной платформы можно отнести невысокую производительность (хотя на данный момент благодаря JIT компиляции в байт- и native-код и быстрой обработке DOM, скорость выполнения приложений имеет хорошие показатели, но как следствие возросло потребление памяти). Также стоит отметить что используются только языки для клиентской части, т. е. пользователь может запустить приложение располагая только каким-либо современным браузером, без необходимости настройки серверной части.
	p Разработка ведётся в тестовом редакторе Sublime Text 3, отладка и запуск выполняется в браузерах Google Chrome и Mozilla Firefox. Также используется средство контроля версий git#[sup #[a(href='#link2')= '[2]']].

	h2#p2_3 2.3 Разработка программной модели

	p Стоит начать с того что весь основной код содержится в функциональном классе Core, который выполняет инициализацию подсистем, пошаговое выполнение команд, а также ввод-вывод данных. Реализация и использование класса Core выглядит следующим образом:
	code
		pre.
			function Core() {
			    var self = this;
			    . . . // Основной код
			}
			var core = new Core();
			    core.init();
			Подсистема памяти инициализируется следующим образом:
			const MEMORY_SIZE = 256; // Количество слов памяти
			self.memory = [];
			for (let addr = 0; addr < MEMORY_SIZE; addr++) {
				setMemory(addr, 0); // Заполняем память нулями
			}
			Регистры описываются следующим образом:
			self.regs = {
			        R1: $$('#reg-R1'),
			        R2: $$('#reg-R2'),
			        RA: $$('#reg-RA'),
			        RS: $$('#reg-RS'),
			        RK: $$('#reg-RK'),
				   SAK: $$('#reg-SAK')
			    };
				self.flags = {
			            S: $$('#flag-S'),
			            Z: $$('#flag-Z'),
			            C: $$('#flag-C'),
			            E: $$('#flag-E')
			        };

	p Инициализация регистров начальными значениями выполняется функцией reset:
	code
		pre.
			this.reset = () => {
			        self.regs.R1.set(0);
			        self.regs.R2.set(0);
			        self.regs.RS.set(0);
			        self.regs.RK.set(0);
			        self.regs.RA.set(0);
			        self.regs.SAK.set(9);
			        self.flags.S.checked = false;
			        self.flags.Z.checked = false;
			        self.flags.C.checked = false;
			        self.flags.E.checked = false;
				};

	p Функция выборки команд и выделения полей из кода команды:
	code
		pre.
			this.step = () => {
			    var SAK = self.regs.SAK.get();
			    var RK = self.memory[SAK];
			    self.regs.RK.set(RK);
			    var R = (RK & 0x10) != 0;
			    var B = (RK >> 5) & 7;
			    var D = (RK >> 8) & 0xF;
			    self.regs.RA.set(self.memory[B] + D);
			    self.regs.SAK.set(SAK + 1);
			    //
			    COMMAND_EXEC[RK & 0xF](R);
			}

	p Для оптимизации процесса выполнения вместо инструкции switch..case используется массив содержащий функции, которые выполняют команду, код которой соответствует индексу массива:
	code
		pre.
			const COMMAND_EXEC = [
			    (R) => { // HLT
			        this.pause();
			        this.regs.SAK.set(this.regs.SAK.get() - 1);
			    },
			    (R) => { // RUN
			        setMemory(8, this.regs.SAK.get());
			        self.regs.SAK.set(this.regs.RA.get());
			    },
			    (R) => { // RET
			        self.regs.SAK.set(this.memory[8]);
			    },
			    (R) => { // LDA
			        setACC(R, self.memory[self.regs.RA.get()]);
			    },
			    (R) => { // SDA
			        setMemory(self.regs.RA.get(), getACC((R)));
			    },
			    (R) => { // JES
			        if (this.flags.S.checked) {
			            self.regs.SAK.set(this.regs.RA.get());
			        }
			    },
			    (R) => { // JEZ
			        if (this.flags.Z.checked) {
			            self.regs.SAK.set(this.regs.RA.get());
			        }
			    },
			    (R) => { // JMP
			        self.regs.SAK.set(this.regs.RA.get());
			    },
			    (R) => { // ADD
			        var res = getACC(R) + self.memory[self.regs.RA.get()];
			        this.flags.Z.checked = (res & 0xFFF) == 0;
			        this.flags.S.checked = (res & 0x800) != 0;
			        this.flags.C.checked = (res & (-1 ^ 0xFFF)) != 0;
			        setACC(R, res);
			    },
			    (R) => { // SUB
			        var res = getACC(R) - self.memory[self.regs.RA.get()];
			        this.flags.Z.checked = (res & 0xFFF) == 0;
			        this.flags.S.checked = (res & 0x800) != 0;
			        this.flags.C.checked = (res & (-1 ^ 0xFFF)) != 0;
			        setACC(R, res);
			    },
			    (R) => { // MUL
			        var res = getACC(R) * self.memory[self.regs.RA.get()];
			        this.flags.Z.checked = (res & 0xFFF) == 0;
			        this.flags.S.checked = (res & 0x800) != 0;
			        this.flags.C.checked = (res & (-1 ^ 0xFFF)) != 0;
			        setACC(R, res);
			    },
			    (R) => { // DIV
			        var op = self.memory[self.regs.RA.get()];
			        if (op != 0) {
			            var res = getACC(R) / op;
			            this.flags.Z.checked = (res & 0xFFF) == 0;
			            this.flags.S.checked = (res & 0x800) != 0;
			            this.flags.C.checked = (res & (-1 ^ 0xFFF)) != 0;
			            setACC(R, res);
			        } else {
			            console.log('Error! Divizion by zero!');
			        }
			    },
			    (R) => { // AND
			        var res = getACC(R) & self.memory[self.regs.RA.get()];
			        this.flags.Z.checked = (res & 0xFFF) == 0;
			        this.flags.S.checked = (res & 0x800) != 0;
			        setACC(R, res);
			    },
			    (R) => { // OR
			        var res = getACC(R) | self.memory[self.regs.RA.get()];
			        this.flags.Z.checked = (res & 0xFFF) == 0;
			        this.flags.S.checked = (res & 0x800) != 0;
			        setACC(R, res);
			    },
			    (R) => { // XOR
			        var res = getACC(R) ^ self.memory[self.regs.RA.get()];
			        this.flags.Z.checked = (res & 0xFFF) == 0;
			        this.flags.S.checked = (res & 0x800) != 0;
			        setACC(R, res);
			    },
			    (R) => { // INC
			        var addr = self.regs.RA.get();
			        var value = self.memory[addr];
			        value = (value + 1) & 0xFFF;
			        setMemory(addr, value);
			        if (this.flags.E.checked = (value == 0)) {
			            self.regs.SAK.set(self.regs.SAK.get() + 1);
			        }
			    },
			];

	p Рассмотрим код ввода-вывода массива памяти. Для формата ввода-вывода используется JSON (англ. JavaScript Object Notation), который поддерживается всеми браузерами и является текстовым представлением полей объектов.
	p Код для вывода данных в файл:
	code
		pre.
			this.upload = () => {
			  var a = document.createElement("a");
			  var file = new Blob([JSON.stringify(this.memory)],
			           {type: 'text/plain'});
			  a.href = URL.createObjectURL(file);
			  a.download = name;
			  a.click();
			};
			Код для ввода данных из файла:
			this.load = (file) => {
			    var fileReader = new FileReader();
			    fileReader.onload = (e) => {
			        var dump = JSON.parse(e.target.result);
			        for (var addr = 0; addr < MEMORY_SIZE; addr++) {
			            setMemory(addr, dump[addr]);
			        }
			    };
			    fileReader.readAsText(file);
			};

	h1#conclusion Выводы
	p Можно сделать следующие выводы, что в данной работе были изучены подсистемы памяти, управление выборкой команд и их выполнения, ввода-вывода, а также виды демонстрационных моделей такие как физические и функциональные.
	p Была разработана простая функциональная модель гипотетической системы, которая демонстрирует работу устройств управления выборкой и выполнения команд, а также взаимодействие с регистрами и внешней памятью.

	h2#literature Литература
	ol.links
		li#link1 Кириллов  В.В. Архитектура  базовой ЭВМ. – СПб: СПбГУ ИТМО, 2010. – 144 с.
		li#link2 Репозиторий проекта модели. [Электронный ресурс]. – git репозиторий – Режим доступа:
			+link('https://github.com/artem8086/emuG2')
		li#link3 Сайт Proteus VSM. [Электронный ресурс]. – Официальный сайт – Режим доступа:
			+link('https://www.labcenter.com')
		li#link4 Сайт Tk Gate. [Электронный ресурс]. – Официальный сайт – Режим доступа:
			+link('http://tkgate.org')
