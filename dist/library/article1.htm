<!DOCTYPE html><html lang="ru"><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"><title>Библиотека &ndash; Святоха А.А., Мальчева Р.В. &ndash; Разработка демонстрационной модели гипотетического компьютера</title><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimal-ui"><meta name="author" content="Святоха Артём Александрович"><link rel="icon" type="image/png" href="../images/masters_i.png"><link rel="stylesheet" href="../css/main.css"></head><body><div class="header container-wrapper"><div class="container"><div class="topmenu clearfix"><div class="left"><a href="../index.htm#library" data-text="Назад в библеотеку" class="icon-link icon-link--no-icon"></a></div><div class="donntu-links right"><a href="http://donntu.org/" target="_blank" data-text="ДонНТУ" class="icon-link icon-link--donntu icon-link--grayscale"></a><a href="http://masters.donntu.org/" target="_blank" data-text="Портал магистров" class="icon-link icon-link--mportal icon-link--grayscale"></a></div><div class="nav-menu right"><div class="nav-button"><span></span></div><div class="nav-wrapper"><div class="nav-list"><a href="http://donntu.org/" target="_blank" data-text="ДонНТУ" class="icon-link icon-link--donntu icon-link--grayscale nav-link"></a><a href="http://masters.donntu.org/" target="_blank" data-text="Портал магистров" class="icon-link icon-link--mportal icon-link--grayscale nav-link"></a></div></div></div></div><div class="head library zx-border"></div></div></div><div class="content container-wrapper"><div class="container library"><h1>Разработка демонстрационной модели гипотетического компьютера</h1><p class="no-indent"><strong>Авторы:</strong> Святоха А.А., Мальчева Р.В.</p><ul class="content-list"><li><a href="#intro">Введение</a></li><li><a href="#p1">1. Анализ средств и способов моделирования компьютерных систем</a><ul><li><a href="#p1_1">1.1 Виды моделей</a></li><li><a href="#p1_2">1.2 Анализ средств</a></li><li><a href="#p1_3">1.3 Примеры моделей компьютерных систем</a></li></ul><a href="#p2">2. Разработка демонстрационной модели гипотетического компьютера</a><ul><li><a href="#p2_1">2.1 Анализ объектов моделирования</a></li><li><a href="#p2_2">2.2 Обоснование выбора платформы</a></li><li><a href="#p2_3">2.3 Разработка программной модели</a></li></ul></li><li><a href="#conclusion">Выводы</a></li><li><a href="#literature">Литература</a></li></ul><h1 id="intro">Введение</h1><p>С каждым годом возрастает роль средств вычислительной техники, при этом все компоненты вычислительных систем располагаются на интегральных микросхемах, не позволяя получить доступ к отдельным узлам или элементам, осложняя тем самым процесс изучения функционирования компьютерных систем и их компонентов.</p><p>Глубокое понимание принципов построения и функционирования сложных систем достигается лишь при практической работе с такими системами или их моделями. Даже самое подробное описание работы с базовым цифровым устройством и детальные иллюстрации процесса выполнения команд не могут заменить действительной работы с этим устройством.</p><p>Данная проблема особенно актуальна в технических вузах и для ее решения разрабатываются специальные модели: физические или функциональные<sup><a href="#link1">[1]</a></sup>, наглядно демонстрирующие представление данных, выполнение операций, взаимодействие с периферией по средствам операций ввода-вывода и системы прерываний.</p><h1 id="p1">1. Анализ средств и способов моделирования компьютерных систем</h1><h2 id="p1_1">1.1 Виды моделей</h2><p>Для моделирования компьютерных систем разрабатываются специальные модели: физические и функциональные<sup><a href="#link1">[1]</a></sup>.</p><p>Физическая модель – это стенд со структурой изучаемого устройства микропроцессорной техники, построенный на интегральных схемах малой и средней степени интеграции и снабженный средствами для управления режимами работы исследуемого устройства, а также индикации состояний любых его компонентов.  В связи с быстрой эволюцией средств микропроцессорной техники массовый выпуск таких специализированных стендов нецелесообразен.  Экономически невыгодно и их мелкосерийное производство.</p><p>Физические модели позволяют проводить физическое исследование компьютеров и цифровых устройств, но так как ввиду роста развития вычислительной техники материальная база быстро устаревает и требует периодической замены лабораторной базы. Кроме того, такие комплексы хороши для подготовки высококвалифицированных кадров в области компьютерной инженерии, но сложны и избыточны для обучения студентов других специальностей.</p><p>Функциональная модель – это компьютер, в который введена программа, имитирующая работу исследуемого устройства микропроцессорной техники под воздействием приказов, подаваемых со специально разработанного пульта управления или, например, со стандартной клавиатуры и мыши компьютера. Состояния компонентов исследуемого устройства отображаются на индикаторах специального пульта или на мониторе компьютера.</p><p>Функциональные модели не требуют специального оборудования, и могут быть продемонстрированы на обычном компьютере, вся необходимая информация отображается на мониторе, и имеется возможность интерактивного взаимодействия с пользователем системы. У функциональной модель также легко изменять как структуру, так и программу изучения функционирования компьютеров либо любого цифрового устройства.</p><h2 id="p1_2">1.2 Анализ средств</h2><p>Функциональные   модели   чрезвычайно универсальны: одни и те же технические средства позволяют производить изучение процесса преобразования информации в любых цифровых устройствах и с любой степенью детализации. Для исследования нового устройства надо только сменить моделирующую программу, программу вывода на экран изображения структуры моделируемого устройства и программу отображения состояния компонентов этого устройства.</p><p>В соответствии со своим назначением функциональная модель должна правильно и полно отражать состояния лишь индицируемых компонентов оригинала и только в индицируемые моменты времени.</p><p>Поэтому   функциональное   моделирование   простейших   цифровых устройств можно выполнять с помощью программы, которая по сигналам органов управления выбирает из памяти и отображает на мониторе соответствующие им состояния компонентов оригинала.</p><p>Следовательно, при создании функциональной модели надо в первую очередь заботиться о способах ввода управляющих сигналов и вывода информации о состояниях моделируемого устройства, т. е. о факторах, определяющих необходимые уровень и полноту исследования. Та же часть программного обеспечения модели, с помощью которой анализируются текущее ее состояние, наличие сигналов, инициирующих переход в следующее состояние, и определяется новое содержимое индицируемых компонентов оригинала, быть построена любым удобным для разработчика способом.</p><p>Если функциональная модель цифрового устройства реализуется с помощью персонального компьютера, то взаимодействие с такой моделью проще и дешевле всего организовать через клавиатуру и мышь этого компьютера и его монитор.</p><p>Первым представителем функциональных моделей является PROTEUS VSM<sup><a href="#link3">[3]</a></sup>, который входит в пакет программ Proteus Design Suite - САПР разработанная компанией Labcenter Electronics (Великобритания). Отличительной чертой пакета PROTEUS VSM является возможность моделирования работы программируемых устройств: микроконтроллеров, микропроцессоров, DSP и проч. Библиотека компонентов содержит справочные данные. Дополнительно в пакет PROTEUS VSM входит система проектирования печатных плат.</p><div class="img"><img src="images/proteus.png" alt="Вид главного окна системы PROTEUS VSM" class="img__image" title=""/><span class="img__caption">Рисунок 1.1 &ndash; Вид главного окна системы PROTEUS VSM</span></div><p>TkGate<sup><a href="#link4">[4]</a></sup> — среда моделирования и симуляции цифровых электронных схем, состоящая из графического редактора с интерфейсом, основанным на tcl/tk и управляемого событиями симулятора. TkGate поддерживает большое количество готовых примитивов, от отдельных транзисторов и вентилей, до стандартных комбинационных и последовательных элементов логических схем. Кроме этого, поддерживается определение модулей в виде графических логических схем или Verilog описаний, а также библиотек модулей для создания сложных иерархических моделей с переиспользованием кода. В дистрибутив входят примеры схем и учебное руководство.</p><div class="img"><img src="images/tkgate.png" alt="TkGate 2.0.0" class="img__image" title=""/><span class="img__caption">Рисунок 1.2 &ndash; TkGate 2.0.0</span></div><h2 id="p1_2">1.3 Примеры моделей компьютерных систем</h2><p>В 1982-83 гг. доцент доцент Кириллов В.В. разработал программную модель «Базовой ЭВМ», которая была реализована на "Искра-226" студентами Громовым Г.Ю., Громовой И.В. и Дергачевым А.М<sup><a href="#link1">[1]</a></sup>.</p><div class="img"><img src="images/sheme1.png" alt="Обобщённая структурная схема компьютера&amp;lt;sup&amp;gt;&amp;lt;a href=&amp;quot;#link1&amp;quot;&amp;gt;[1]&amp;lt;/a&amp;gt;&amp;lt;/sup&amp;gt;" class="img__image" title=""/><span class="img__caption">Рисунок 1.3 &ndash; Обобщённая структурная схема компьютера<sup><a href="#link1">[1]</a></sup></span></div><p>Был разработан и изготовлен специальный пульт управления моделью и индикации ее состояний позволит организовать наиболее эффективное взаимодействие с моделью и получить всю необходимую информацию о ее функционировании.</p><p>На <a href="#img1_4">рисунке 1.4,а</a> приведен внешний вид, а на <a href="#img1_4">рисунке 1.4,б</a> – структурная схема пульта управления  и  индикации,  используемого  для  изучения работы базовой ЭВМ. Пульт состоит из набора тумблеров и кнопок, индикатора матричного газоразрядного (ИМГ-3), контроллера для связи клавиатуры и индикатора с управляющей (моделирующей) ЭВМ.</p><div class="img" id="img1_4"><img src="images/sheme2.png" alt="Пульт   управления   и индикации   функциональных моделей микроЭВМ: а - внешний вид; б - структурная схема&amp;lt;sup&amp;gt;&amp;lt;a href=&amp;quot;#link1&amp;quot;&amp;gt;[1]&amp;lt;/a&amp;gt;&amp;lt;/sup&amp;gt;" class="img__image" title=""/><span class="img__caption">Рисунок 1.4 &ndash; Пульт   управления   и индикации   функциональных моделей микроЭВМ: а - внешний вид; б - структурная схема<sup><a href="#link1">[1]</a></sup></span></div><p>ИМГ-3 – газоразрядная панель с устройством управления, которое может зажечь любой из 4096 (64X64) элементов изображения (ЭИ) размером 3X3 мм, расположенных на расстоянии 3 мм друг от друга. На панель накладывается маска со структурой базовой ЭВМ или ее микропрограммным устройством управления. В изображениях регистров и других устройств этих масок пробиты круглые отверстия, расположенные над ЭИ панели.  Моделирующая программа зажигает ярким зеленым цветом ряд ЭИ, соответствующих единичным состояниям тех или иных разрядов устройств базовой ЭВМ.</p><p>Для задания адреса ячейки памяти или ввода данных в модель базовой   ЭВМ, построенной   на "Искра 226", используются функциональные клавиши клавиатуры этой персональной ЭВМ (<a href="img1_5">рисунок 1.5</a>).</p><div class="img" id="img1_5"><img src="images/photo1.jpg" alt="Профессиональная персональная ЭВМ «Искра 226»" class="img__image" title=""/><span class="img__caption">Рисунок 1.5 &ndash; Профессиональная персональная ЭВМ «Искра 226»</span></div><h1 id="p2">2. Разработка демонстрационной модели гипотетического компьютера</h1><h2 id="p2_1">2.1 Анализ объектов моделирования</h2><p>Гипотетическая компьютерная система предназначена в первую очередь наглядно продемонстрировать основы работы компьютера, и всех его подсистем, таких как подсистема памяти, управления и подсистем ввода-вывода. Практически любой компьютер содержит в себе процессор, в состав которого входят<sup><a href="#link1">[1]</a></sup>:</p><ul class="no-mark"><li>- устройство управления выборкой команд из памяти и их выполнением;</li><li>- арифметико-логическое устройство, производящее операции на данными;</li><li>- регистры, осуществляющие временное хранение данных и состояний процессора;</li><li>- схемы для управления и связи с подсистемами связи и вводы-вывода.</li></ul><p>В понимания принципов функционирования и взаимосвязи этих систем, помогает демонстрационная модель гипотетической компьютерной системы. Которая позволяет следить за изменением состояния системы, в любом промежутке её работы.</p><div class="img"><img src="images/sheme3.png" alt="Структурная схема рассматриваемой модели" class="img__image" title=""/><span class="img__caption">Рисунок 2.1 &ndash; Структурная схема рассматриваемой модели</span></div><h2 id="p2_2">2.2 Обоснование выбора платформы</h2><p>Для разработки демонстрационной модели были выбраны языки разработки веб приложений HTML5, CSS3 и JavaScript. Выбор базируется на кроссплатформенности платформы веб, запуске приложения без необходимости компиляции, простоту разработки, а также богатыми средствами визуализации и интерактивного взаимодействия с пользователем. К минусам данной платформы можно отнести невысокую производительность (хотя на данный момент благодаря JIT компиляции в байт- и native-код и быстрой обработке DOM, скорость выполнения приложений имеет хорошие показатели, но как следствие возросло потребление памяти). Также стоит отметить что используются только языки для клиентской части, т. е. пользователь может запустить приложение располагая только каким-либо современным браузером, без необходимости настройки серверной части.</p><p>Разработка ведётся в тестовом редакторе Sublime Text 3, отладка и запуск выполняется в браузерах Google Chrome и Mozilla Firefox. Также используется средство контроля версий git<sup><a href="#link2">[2]</a></sup>.</p><h2 id="p2_3">2.3 Разработка программной модели</h2><p>Стоит начать с того что весь основной код содержится в функциональном классе Core, который выполняет инициализацию подсистем, пошаговое выполнение команд, а также ввод-вывод данных. Реализация и использование класса Core выглядит следующим образом:</p><code><pre>function Core() {
    var self = this;
    . . . // Основной код
}
var core = new Core();
    core.init();
Подсистема памяти инициализируется следующим образом:
const MEMORY_SIZE = 256; // Количество слов памяти
self.memory = [];
for (let addr = 0; addr < MEMORY_SIZE; addr++) {
	setMemory(addr, 0); // Заполняем память нулями
}
Регистры описываются следующим образом:
self.regs = {
        R1: $$('#reg-R1'),
        R2: $$('#reg-R2'),
        RA: $$('#reg-RA'),
        RS: $$('#reg-RS'),
        RK: $$('#reg-RK'),
	   SAK: $$('#reg-SAK')
    };
	self.flags = {
            S: $$('#flag-S'),
            Z: $$('#flag-Z'),
            C: $$('#flag-C'),
            E: $$('#flag-E')
        };
</pre></code><p>Инициализация регистров начальными значениями выполняется функцией reset:</p><code><pre>this.reset = () => {
        self.regs.R1.set(0);
        self.regs.R2.set(0);
        self.regs.RS.set(0);
        self.regs.RK.set(0);
        self.regs.RA.set(0);
        self.regs.SAK.set(9);
        self.flags.S.checked = false;
        self.flags.Z.checked = false;
        self.flags.C.checked = false;
        self.flags.E.checked = false;
	};
</pre></code><p>Функция выборки команд и выделения полей из кода команды:</p><code><pre>this.step = () => {
    var SAK = self.regs.SAK.get();
    var RK = self.memory[SAK];
    self.regs.RK.set(RK);
    var R = (RK & 0x10) != 0;
    var B = (RK >> 5) & 7;
    var D = (RK >> 8) & 0xF;
    self.regs.RA.set(self.memory[B] + D);
    self.regs.SAK.set(SAK + 1);
    //
    COMMAND_EXEC[RK & 0xF](R);
}
</pre></code><p>Для оптимизации процесса выполнения вместо инструкции switch..case используется массив содержащий функции, которые выполняют команду, код которой соответствует индексу массива:</p><code><pre>const COMMAND_EXEC = [
    (R) => { // HLT
        this.pause();
        this.regs.SAK.set(this.regs.SAK.get() - 1);
    },
    (R) => { // RUN
        setMemory(8, this.regs.SAK.get());
        self.regs.SAK.set(this.regs.RA.get());
    },
    (R) => { // RET
        self.regs.SAK.set(this.memory[8]);
    },
    (R) => { // LDA
        setACC(R, self.memory[self.regs.RA.get()]);
    },
    (R) => { // SDA
        setMemory(self.regs.RA.get(), getACC((R)));
    },
    (R) => { // JES
        if (this.flags.S.checked) {
            self.regs.SAK.set(this.regs.RA.get());
        }
    },
    (R) => { // JEZ
        if (this.flags.Z.checked) {
            self.regs.SAK.set(this.regs.RA.get());
        }
    },
    (R) => { // JMP
        self.regs.SAK.set(this.regs.RA.get());
    },
    (R) => { // ADD
        var res = getACC(R) + self.memory[self.regs.RA.get()];
        this.flags.Z.checked = (res & 0xFFF) == 0;
        this.flags.S.checked = (res & 0x800) != 0;
        this.flags.C.checked = (res & (-1 ^ 0xFFF)) != 0;
        setACC(R, res);
    },
    (R) => { // SUB
        var res = getACC(R) - self.memory[self.regs.RA.get()];
        this.flags.Z.checked = (res & 0xFFF) == 0;
        this.flags.S.checked = (res & 0x800) != 0;
        this.flags.C.checked = (res & (-1 ^ 0xFFF)) != 0;
        setACC(R, res);
    },
    (R) => { // MUL
        var res = getACC(R) * self.memory[self.regs.RA.get()];
        this.flags.Z.checked = (res & 0xFFF) == 0;
        this.flags.S.checked = (res & 0x800) != 0;
        this.flags.C.checked = (res & (-1 ^ 0xFFF)) != 0;
        setACC(R, res);
    },
    (R) => { // DIV
        var op = self.memory[self.regs.RA.get()];
        if (op != 0) {
            var res = getACC(R) / op;
            this.flags.Z.checked = (res & 0xFFF) == 0;
            this.flags.S.checked = (res & 0x800) != 0;
            this.flags.C.checked = (res & (-1 ^ 0xFFF)) != 0;
            setACC(R, res);
        } else {
            console.log('Error! Divizion by zero!');
        }
    },
    (R) => { // AND
        var res = getACC(R) & self.memory[self.regs.RA.get()];
        this.flags.Z.checked = (res & 0xFFF) == 0;
        this.flags.S.checked = (res & 0x800) != 0;
        setACC(R, res);
    },
    (R) => { // OR
        var res = getACC(R) | self.memory[self.regs.RA.get()];
        this.flags.Z.checked = (res & 0xFFF) == 0;
        this.flags.S.checked = (res & 0x800) != 0;
        setACC(R, res);
    },
    (R) => { // XOR
        var res = getACC(R) ^ self.memory[self.regs.RA.get()];
        this.flags.Z.checked = (res & 0xFFF) == 0;
        this.flags.S.checked = (res & 0x800) != 0;
        setACC(R, res);
    },
    (R) => { // INC
        var addr = self.regs.RA.get();
        var value = self.memory[addr];
        value = (value + 1) & 0xFFF;
        setMemory(addr, value);
        if (this.flags.E.checked = (value == 0)) {
            self.regs.SAK.set(self.regs.SAK.get() + 1);
        }
    },
];
</pre></code><p>Рассмотрим код ввода-вывода массива памяти. Для формата ввода-вывода используется JSON (англ. JavaScript Object Notation), который поддерживается всеми браузерами и является текстовым представлением полей объектов.</p><p>Код для вывода данных в файл:</p><code><pre>this.upload = () => {
  var a = document.createElement("a");
  var file = new Blob([JSON.stringify(this.memory)],
           {type: 'text/plain'});
  a.href = URL.createObjectURL(file);
  a.download = name;
  a.click();
};
Код для ввода данных из файла:
this.load = (file) => {
    var fileReader = new FileReader();
    fileReader.onload = (e) => {
        var dump = JSON.parse(e.target.result);
        for (var addr = 0; addr < MEMORY_SIZE; addr++) {
            setMemory(addr, dump[addr]);
        }
    };
    fileReader.readAsText(file);
};
</pre></code><h1 id="conclusion">Выводы</h1><p>Можно сделать следующие выводы, что в данной работе были изучены подсистемы памяти, управление выборкой команд и их выполнения, ввода-вывода, а также виды демонстрационных моделей такие как физические и функциональные.</p><p>Была разработана простая функциональная модель гипотетической системы, которая демонстрирует работу устройств управления выборкой и выполнения команд, а также взаимодействие с регистрами и внешней памятью.</p><h2 id="literature">Литература</h2><ol><li id="link1">Кириллов  В.В. Архитектура  базовой ЭВМ. – СПб: СПбГУ ИТМО, 2010. – 144 с.</li><li id="link2">Репозиторий проекта модели. [Электронный ресурс]. – git репозиторий – Режим доступа:<a href="https://github.com/artem8086/emuG2">https://github.com/artem8086/emuG2</a></li><li id="link3">Сайт Proteus VSM. [Электронный ресурс]. – официальный сайт – Режим доступа:<a href="https://www.labcenter.com">https://www.labcenter.com</a></li><li id="link4">Сайт Tk Gate. [Электронный ресурс]. – официальный сайт – Режим доступа:<a href="http://tkgate.org">http://tkgate.org</a></li></ol></div></div><div class="footer container-wrapper"><div class="container"><div class="footer__counter"><!-- BEGIN OF PING CODE v5.1--><script language="javascript">//<!--
id="112802155341";img="count30";script="http://counter.topping.com.ua:80/cgi-bin/pinger.cgi";d=document;an=navigator.appName;rf=escape(d.referrer);w="";c="";jv="0";je="u";//--></script><script language="javascript1.1">//<!--
jv="1";je = (navigator.javaEnabled()?"y":"n");//--></script><script language="javascript1.2">//<!--
s=screen;w=s.width;an!="Netscape"?c=s.colorDepth:c=s.pixelDepth;jv="2";//--></script><script language="javascript1.3">//<!--
jv="3";//--></script><script language="javascript">//<!--
pi="";pi+="\""+script+"?id="+id+"&img="+img+"&w="+w+"&c="+c+"&ref="+rf+"&jsv="+jv+"&jen="+je+"\"";pi="<a href=http://www.topping.com.ua/ target=_blank><img src="+pi+" width=88 height=31 border=0 alt=\"Rated by PING\"></a>";d.write(pi);//--></script><noscript><a href="http://www.topping.com.ua/rating/donetsk/" target="_blank"><img src="http://counter.topping.com.ua:80/cgi-bin/ping.cgi?112802155341;count30" alt="Rated by PING" width="88" height="31" border="0"></a></noscript><!-- END OF PING CODE v5.1--></div><div class="footer__counter"><!-- Rating@Mail.ru counter--><script language="javascript"><!--
d=document;var a='';a+=';r='+escape(d.referrer);js=10;//--></script><script language="javascript1.1"><!--
a+=';j='+navigator.javaEnabled();js=11;//--></script><script language="javascript1.2"><!--
s=screen;a+=';s='+s.width+'*'+s.height;
a+=';d='+(s.colorDepth?s.colorDepth:s.pixelDepth);js=12;//--></script><script language="javascript1.3"><!--
js=13;//--></script><script language="javascript" type="text/javascript"><!--
d.write('<a href="http://top.mail.ru/jump?from=407990" target="_top">'+
'<img src="http://d9.c3.b6.a0.top.mail.ru/counter?id=407990;t=56;js='+js+
a+';rand='+Math.random()+'" alt="Рейтинг@Mail.ru" border="0" '+
'height="31" width="88"></a>');if(11<js)d.write('<'+'!-- ');//--></script><noscript><a target="_top" href="http://top.mail.ru/jump?from=407990"><img src="http://d9.c3.b6.a0.top.mail.ru/counter?js=na;id=407990;t=56" alt="Рейтинг@Mail.ru" width="88" height="31" border="0"></a></noscript><script language="javascript" type="text/javascript"><!--
if(11<js)d.write('--'+'>');//--></script><!-- // Rating@Mail.ru counter--></div><div class="footer__counter"><!-- bigmir)net TOP 100--><a href="http://top.bigmir.net/show/science/" target="_blank"><script language="javascript"><!--
bmQ='<img src=http://c.bigmir.net/?s38404&t5'
bmD=document
bmD.cookie="b=b"
if(bmD.cookie)bmQ+='&c1'
//--></script><script language="javascript1.2"><!--
bmS=screen;bmQ+='&d'+(bmS.colorDepth?bmS.colorDepth:bmS.pixelDepth)+"&r"+bmS.width;
//--></script><script language="javascript"><!--
bmF = bmD.referrer.slice(7);
((bmI=bmF.indexOf('/'))!=-1)?(bmF=bmF.substring(0,bmI)):(bmI=bmF.length);
if(bmF!=window.location.href.substring(7,7+bmI))bmQ+='&f'+escape(bmD.referrer);
bmD.write(bmQ+" border=0 width=88 height=31 alt='bigmir TOP100'>");
//--></script></a></div><div class="footer__counter"><!-- Openstat--><span id="openstat2124156"></span><script type="text/javascript">var openstat = { counter: 2124156, image: 5045, next: openstat }; document.write(unescape("%3Cscript%20src=%22http" +
(("https:" == document.location.protocol) ? "s" : "") +
"://openstat.net/cnt.js%22%20defer=%22defer%22%3E%3C/script%3E"));</script><!-- /Openstat--><!-- LiveInternet counter--><script type="text/javascript"><!--
document.write("<a href='//www.liveinternet.ru/click' "+
"target=_blank><img src='//counter.yadro.ru/hit?t44.6;r"+
escape(document.referrer)+((typeof(screen)=="undefined")?"":
";s"+screen.width+"*"+screen.height+"*"+(screen.colorDepth?
screen.colorDepth:screen.pixelDepth))+";u"+escape(document.URL)+
";"+Math.random()+
"' alt='' title='LiveInternet' "+
"border='0' width='1' height='1'></a>")
//-->
// /LiveInternet</script></div></div></div><script src="https://code.jquery.com/jquery-3.3.1.min.js"></script><script src="../js/main.js"></script></body></html>